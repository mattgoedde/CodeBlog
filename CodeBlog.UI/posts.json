[
  {
    "Content": "This guide will walk through the implementation of a metadata service for this Code Blog application.\n\n##### Goal\n\nSearch engines rely on meta data in the head of the HTML content for optimization. The goal is to provide these meta data tags in a programmatic way based on each page of our site.\n\n\u0060\u0060\u0060 html\n\u0026lt;head\u0026gt;\n\t\u0026lt;title\u0026gt;Page Title\u0026lt;/title\u0026gt;\n\t\u0026lt;meta name=\u0026quot;author\u0026quot; content=\u0026quot;\u0026quot; /\u0026gt;\n\t\u0026lt;meta name=\u0026quot;keywords\u0026quot; content=\u0026quot;\u0026quot; /\u0026gt;\n\t\u0026lt;meta name=\u0026quot;other-custom-meta\u0026quot; content=\u0026quot;\u0026quot; /\u0026gt;\n\u0026lt;/head\u0026gt;\n\u0060\u0060\u0060\n\nFor example, each page of this site is an entry into a database. Each article that is visible to the public is dynamically created from content that is retrieved from the database. Thus, pages are created and served dynamically, and metadata cannot be maintained manually.\n\nWe want key pieces of data from each article to make it to the head of the HTML content. When a new article is written, its data should be present in the head even though it was created after the start of the application.\n\n##### Layout and HeadContent\n\nIn a Blazor Server templated project, the \u0060_Layout.cshtml\u0060 file contains the \u0060\u0026lt;head\u0026gt;\u0060 element of the HTML. This is the target of our efforts. \n\nYou will see a Razor component already present here:\n\u0060\u0060\u0060 html\n\u0026lt;component type=\u0026quot;typeof(HeadOutlet)\u0026quot; render-mode=\u0026quot;ServerPrerendered\u0026quot; /\u0026gt;\n\u0060\u0060\u0060\n\nThis is accessible in Razor components by doing the following:\n\u0060\u0060\u0060 html\n\u0026lt;HeadContent\u0026gt;\n\t\u0026lt;head\u0026gt;\n\t\t\u0026lt;title\u0026gt;Page Title\u0026lt;/title\u0026gt;\n\t\t\u0026lt;meta name=\u0026quot;author\u0026quot; content=\u0026quot;\u0026quot; /\u0026gt;\n\t\t\u0026lt;meta name=\u0026quot;keywords\u0026quot; content=\u0026quot;\u0026quot; /\u0026gt;\n\t\t\u0026lt;meta name=\u0026quot;other-custom-meta\u0026quot; content=\u0026quot;\u0026quot; /\u0026gt;\n\t\u0026lt;/head\u0026gt;\n\u0026lt;/HeadContent\u0026gt;\n\u0060\u0060\u0060\nBut, can we trust ourselves to update this for every page?\n\n##### Stored Data\n\nBesides trusting ourselves to update each page with this content, wouldn\u0026#39;t it be great to store it in a structured manner so we can query it, like a search bar?\n\nIn the instance of this application, we have a class defined for each blog post, \u0060Post.cs\u0060. This class is what is serialized and stored in the database for each blog post.\n\n**Post.cs**\n\u0060\u0060\u0060 csharp\npublic abstract record EntityBase\n{\n\tpublic MetadataValues Metadata { get; init; } = default!;\n}\n\n[Serializable]\npublic record Post : EntityBase\n{\n\tpublic string Content { get; init; } = string.Empty;\n\n\tpublic override string ToString()\n\t{\n\t\treturn JsonSerializer.Serialize(this, new JsonSerializerOptions() { WriteIndented = true });\n\t}\n}\n\n[Serializable]\npublic record MetadataEntity : EntityBase\n{\n\tpublic string Type { get; init; } = string.Empty;\n\n\tpublic MetadataEntity() { }\n\n\tprivate MetadataEntity(Type type)\n\t{\n\t\tType = type.Name;\n\t}\n\n\tpublic static MetadataEntity FromType\u0026lt;T\u0026gt;(MetadataValues metadata)\n\t{\n\t\treturn new MetadataEntity(typeof(T)) { Metadata = metadata};\n\t}\n}\n\u0060\u0060\u0060\nThese classes contain an object of type \u0060MetadataValues\u0060. Logically, every post will have metadata values. In the future, other classes may have \u0060MetadataValues\u0060, such as a comment on a post.\n\n**MetadataValues.cs**\n\u0060\u0060\u0060 csharp\n[Serializable]\npublic record MetadataValues\n{\n\tpublic Guid Id { get; init; } = Guid.Empty;\n\tpublic string Title { get; init; } = string.Empty;\n\tpublic string Description { get; init; } = string.Empty;\n\tpublic DateTime CreatedAt { get; init; }\n\tpublic DateTime UpdatedAt { get; init; }\n\tpublic string Author { get; init; } = string.Empty;\n\tpublic IEnumerable\u0026lt;string\u0026gt; Keywords { get; init; } = Enumerable.Empty\u0026lt;string\u0026gt;();\n\n\tpublic string SocialMediaCardTitle =\u0026gt; $\u0026quot;Goedde\u0026#39;s Code Blog - {Title}\u0026quot;;\n\n\tpublic override string ToString()\n\t{\n\t\treturn JsonSerializer.Serialize(this, new JsonSerializerOptions() { WriteIndented = true });\n\t}\n}\n\u0060\u0060\u0060\n\nNow we have a structured way of representing Metadata about _something_. How do we get this data into the head of each page that represents a \u0060Post\u0060?\n\n##### Programmatically Retrieving Metadata\n\n_Enter \u0060IRouteMetadataProvider\u0060_\n\n**IRouteMetadataProvider.cs**\n\u0060\u0060\u0060 csharp\npublic interface IRouteMetadataProvider\n{\n\tTask\u0026lt;IDictionary\u0026lt;string, MetadataValues\u0026gt;\u0026gt; GetRouteMetadataAsync(CancellationToken cancellationToken = default);\n}\n\u0060\u0060\u0060\n\nLet\u0026#39;s create a service that exposes a way to retrieve all of our Metadata organized by its route. This method will return all \u0060MetadataValues\u0060 from \u0060Post[s]\u0060 and key them by the URL route they are accessible by.\n\nBut wait! We already have a way of retrieving \u0060MetadataValues\u0060 from \u0060Post[s]\u0060 from our Metadata implementation of \u0060IRepository\u0026lt;T\u0026gt;\u0060! Why wouldn\u0026#39;t we use that same service?\n\n**MetadataRepository.cs**\n\u0060\u0060\u0060 csharp\npublic class MetadataRepository : FileWriteRepositoryBase\u0026lt;MetadataEntity\u0026gt;, IRouteMetadataProvider\n{\n\t// ...\n\tpublic async Task\u0026lt;IDictionary\u0026lt;string, MetadataValues\u0026gt;\u0026gt; GetRouteMetadataAsync(CancellationToken cancellationToken = default)\n\t{\n\t\tvar metas = await Read(cancellationToken);\n\n\t\treturn metas.ToDictionary(m =\u0026gt; $\u0026quot;{m.Type}/{m.Metadata.Id}\u0026quot;, m =\u0026gt; m.Metadata);\n\t}\n}\n\u0060\u0060\u0060\n\nPerfect. Moving along...\n\n##### Serving the Route Metadata\nSo how do we know _which_ \u0060MetadataValues\u0060 we need to put in the HTML content? This should be based off the URL route we are currently on. If the current route doesn\u0026#39;t have metadata,  we should serve default data. Otherwise, retrieve it from our \u0060IRouteMetadataProvider\u0060.\n\n**MetadataTransferService.cs**\n\nOk this one is a doozy, so we\u0026#39;ll go step by step.\n\nWe know we need to know our URL route, let\u0026#39;s inject \u0060NavigationManager\u0060.\n\u0060\u0060\u0060 csharp\npublic class MetadataTransferService\n{\n\tprivate readonly NavigationManager _navigationManager;\n\tpublic MetadataTransferService(NavigationManager navigationManager)\n\t{\n\t\t_navigationManager = navigationManager;\n\t}\n}\n\u0060\u0060\u0060\n\nWe also know we need to serve a \u0060MetadataValues\u0060 object depending on that route, let\u0026#39;s stub a method to do that.\n\u0060\u0060\u0060 csharp\npublic class MetadataTransferService\n{\n\tprivate readonly NavigationManager _navigationManager;\n\t\n\tpublic MetadataValues? SelectedMetadata { get; set; } // The current MetadataValues\n\t\n\tpublic MetadataTransferService(NavigationManager navigationManager)\n\t{\n\t\t_navigationManager = navigationManager;\n\t}\n\t\n\tprivate void UpdateMetadata(string url)\n\t{\n\t\tSelectedMetadata = new (); // TODO Determine which\n\t}\n}\n\u0060\u0060\u0060\n\nExploring the \u0060NavigationManager\u0060, we find an \u0060EventHandler\u0060 named \u0060LocationChanged\u0060. This is perfect.\n\nThis is how we can determine our URL!\n\u0060\u0060\u0060 csharp\npublic class MetadataTransferService\n{\n\tprivate readonly NavigationManager _navigationManager;\n\t\n\tpublic MetadataValues? SelectedMetadata { get; set; } // The current MetadataValues\n\t\n\tpublic MetadataTransferService(NavigationManager navigationManager)\n\t{\n\t\t_navigationManager = navigationManager;\n\t}\n\t\n\tprivate void UpdateMetadata(string url)\n\t{\n\t\tSelectedMetadata = new (); // TODO Determine which\n\t}\n\t\n\tprivate void UpdateMetadata(object? sender, LocationChangedEventArgs e)\n\t{\n\t\tUpdateMetadata(e.Location); // e.Location is our URL\n\t}\n}\n\u0060\u0060\u0060\n\nNext we need to inject our data source for \u0060MetadataValues\u0060. However, so far our call stack has been synchronous. Our \u0060IRouteMetadataProvider\u0060 exposes a \u0060Task\u0060 to get that data.\n\nThe different approach to this problem is _configuring_ the Metadata data using the Options pattern. Let\u0026#39;s create an options container, configure it, then inject it.\n\n**MetadataOptions.cs**\n\u0060\u0060\u0060csharp\npublic class MetadataOptions\n{\n\tpublic IDictionary\u0026lt;string, MetadataValues\u0026gt; Metadatas { get; set; } = ImmutableDictionary\u0026lt;string, MetadataValues\u0026gt;.Empty;\n}\n\u0060\u0060\u0060\n**IServiceCollection.Extensions.cs**\n\n\u0060\u0060\u0060csharp\npublic static class IServiceCollectionExtensions\n{\n\tpublic static IServiceCollection AddMetadata(this IServiceCollection services)\n\t{\n\t\tservices\n\t\t\t.AddSingleton\u0026lt;IRouteMetadataProvider, MetadataRepository\u0026gt;()\n\t\t\t.AddScoped\u0026lt;MetadataTransferService\u0026gt;();\n\t\tservices.AddOptions\u0026lt;MetadataOptions\u0026gt;(\u0026quot;MetadataOptions\u0026quot;)\n\t\t\t.Configure\u0026lt;IRouteMetadataProvider\u0026gt;(async (options, provider) =\u0026gt;\n\t\t\t{\n\t\t\t\t// Add custom metadata objects by route here:\n\t\t\t\toptions.Metadatas = new Dictionary\u0026lt;string, MetadataValues\u0026gt;\n\t\t\t\t{\n\t\t\t\t\t{\n\t\t\t\t\t\t\u0026quot;/\u0026quot;,\n\t\t\t\t\t\tnew MetadataValues()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tAuthor = \u0026quot;Matthew Goedde\u0026quot;,\n\t\t\t\t\t\t\tDescription = \u0026quot;Matthew Goedde\u0026#39;s Code Blog. A CMS site serving Markdown blog posts to readers on the topic of code.\u0026quot;,\n\t\t\t\t\t\t\tKeywords = new string[] { \u0026quot;code\u0026quot;, \u0026quot;tutorials\u0026quot;, \u0026quot;blog\u0026quot;, \u0026quot;C#\u0026quot;, \u0026quot;dotnet\u0026quot;, \u0026quot;.NET\u0026quot;, \u0026quot;blazor\u0026quot;, \u0026quot;SQL\u0026quot;, \u0026quot;Markdown\u0026quot; },\n\t\t\t\t\t\t\tTitle = \u0026quot;Code Blog\u0026quot;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\toptions.Metadatas = options.Metadatas.Union(await provider.GetRouteMetadataAsync()).ToDictionary(k =\u0026gt; k.Key, v =\u0026gt; v.Value);\n\t\t\t});\n\n\t\treturn services;\n\t}\n}\n\u0060\u0060\u0060\n\n**MetadataTransferService.cs** \n\u0060\u0060\u0060csharp\npublic class MetadataTransferService : INotifyPropertyChanged, IDisposable\n{\n\tpublic event PropertyChangedEventHandler? PropertyChanged;\n\n\tprivate readonly NavigationManager _navigationManager;\n\n\tprivate readonly MetadataOptions _options;\n\n\tprivate MetadataValues? _selectedMetadata;\n\tpublic MetadataValues? SelectedMetadata { get =\u0026gt; _selectedMetadata; set { _selectedMetadata = value; OnPropertyChanged(); } }\n\n\tprivate void OnPropertyChanged([CallerMemberName] string propertyName = \u0026quot;\u0026quot;)\n\t{\n\t\tPropertyChanged?.Invoke(this, new(propertyName));\n\t}\n\n\tpublic MetadataTransferService(NavigationManager navigationManager, IOptionsMonitor\u0026lt;MetadataOptions\u0026gt; optionsDelegate)\n\t{\n\t\t_navigationManager = navigationManager;\n\n\t\t_options = optionsDelegate.Get(\u0026quot;MetadataOptions\u0026quot;);\n\n\t\tSelectedMetadata = _options.Metadatas[\u0026quot;/\u0026quot;];\n\n\t\t_navigationManager.LocationChanged \u002B= UpdateMetadata;\n\t}\n\n\tprivate void UpdateMetadata(string url)\n\t{\n\t\tSelectedMetadata = _options.Metadatas.FirstOrDefault(vp =\u0026gt; url.EndsWith(vp.Key)).Value;\n\t\tif (SelectedMetadata is null) SelectedMetadata = _options.Metadatas[\u0026quot;/\u0026quot;];\n\t}\n\n\tprivate void UpdateMetadata(object? sender, LocationChangedEventArgs e)\n\t{\n\t\tUpdateMetadata(e.Location);\n\t}\n\n\tpublic void Dispose()\n\t{\n\t\t_navigationManager.LocationChanged -= UpdateMetadata;\n\t\tGC.SuppressFinalize(this);\n\t}\n}\n\u0060\u0060\u0060\n\nSo cleaning up a little bit, we injected the options into \u0060MetadataTransferService\u0060 and retrieved our data from the options object. If null, we retrieve our default. We also make it disposable to remove the \u0060EventHandler\u0060.  We also implement \u0060INotifyPropertyChanged\u0060 to fire an event when the URL changes.\n\n##### The Razor Component\nOkay, you could see this one coming. We are going to make a custom Razor component to create the markup in the \u0060\u0026lt;head\u0026gt;\u0060 element.\n\nWe can inject our \u0060MetadataTransferService\u0060 and hook onto its implementation of \u0060INotifyPropertyChanged\u0060 to re-build the \u0060\u0026lt;meta\u0026gt;\u0060 tags.\n\n\u0060\u0060\u0060 csharp\n@using System.ComponentModel\n@implements IDisposable\n\n@if (metadataTransferService.SelectedMetadata is not null)\n{\n\t\u0026lt;title\u0026gt;@metadataTransferService.SelectedMetadata.Title\u0026lt;/title\u0026gt;\n\n\t\u0026lt;meta name=\u0026quot;keywords\u0026quot; content=\u0026quot;@(string.Join(\u0026quot;, \u0026quot;, metadataTransferService.SelectedMetadata.Keywords))\u0026quot; /\u0026gt;\n\t\u0026lt;meta name=\u0026quot;description\u0026quot; content=\u0026quot;@(metadataTransferService.SelectedMetadata.Description)\u0026quot; /\u0026gt;\n\t\u0026lt;meta name=\u0026quot;author\u0026quot; content=\u0026quot;@(metadataTransferService.SelectedMetadata.Author)\u0026quot; /\u0026gt;\n\t\u0026lt;meta name=\u0026quot;og:title\u0026quot; content=\u0026quot;@(metadataTransferService.SelectedMetadata.SocialMediaCardTitle)\u0026quot; /\u0026gt;\n\t\u0026lt;meta name=\u0026quot;twitter:card\u0026quot; content=\u0026quot;@(metadataTransferService.SelectedMetadata.SocialMediaCardTitle)\u0026quot; /\u0026gt;\n}\n\n@code {\n\n\t[Inject]\n\tprotected MetadataTransferService metadataTransferService { get; set; }\n\n\tprotected override void OnInitialized()\n\t{\n\t\tmetadataTransferService.PropertyChanged \u002B= OnMetadataChanged;\n\t}\n\n\tprivate void OnMetadataChanged(object sender, PropertyChangedEventArgs e) \n\t{\n\t\tStateHasChanged();\n\t}\n\n\tpublic void Dispose()\n\t{\n\t\tmetadataTransferService.PropertyChanged -= OnMetadataChanged;\n\t}\n}\n\u0060\u0060\u0060\n\n\n##### Finishing touches\nAll that\u0026#39;s left is this in **\\_Layout.cshtml**\n\u0060\u0060\u0060html\n\u0026lt;!--\u0026lt;component type=\u0026quot;typeof(HeadOutlet)\u0026quot; render-mode=\u0026quot;ServerPrerendered\u0026quot; /\u0026gt;--\u0026gt;\n\u0026lt;component type=\u0026quot;typeof(Metadata)\u0026quot; render-mode=\u0026quot;ServerPrerendered\u0026quot; /\u0026gt;\n\u0060\u0060\u0060\nFinally, we add the following line to **Program.cs**\n\u0060\u0060\u0060\nbuilder.Services.AddMetadata();\n\u0060\u0060\u0060\n\n##### Conclusion\n\nThis method is advantageous because new pages will not need to know of how metadata is built for a solid implementation. If a new page would need custom metadata, it could create it with the matching route in the options configuration.",
    "Metadata": {
      "Id": "c6369514-0ba2-4600-baef-d28d2da07710",
      "Title": "Blazor - SEO \u0026 Metadata",
      "Description": "A quick guide on Metadata for Blazor Server to improve Search Engine Optimization (SEO)",
      "CreatedAt": "2022-08-10T13:59:10.2940274-04:00",
      "UpdatedAt": "2022-08-23T13:51:03.7827945-04:00",
      "Author": "Matthew Goedde",
      "Keywords": [
        "Blazor",
        "C#",
        ".NET 6.0",
        "Metadata",
        "HTML",
        ".NET",
        "CMS"
      ],
      "SocialMediaCardTitle": "Goedde\u0027s Code Blog - Blazor - SEO \u0026 Metadata"
    }
  },
  {
    "Content": "Test Test",
    "Metadata": {
      "Id": "08e90b73-38f1-4c89-9edb-244f8e3750c6",
      "Title": "New Post",
      "Description": "Test",
      "CreatedAt": "2022-08-23T13:51:23.6361372-04:00",
      "UpdatedAt": "2022-08-23T13:52:06.991835-04:00",
      "Author": "Matthew Goedde",
      "Keywords": [
        "Test"
      ],
      "SocialMediaCardTitle": "Goedde\u0027s Code Blog - New Post"
    }
  }
]